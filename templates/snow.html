{% extends "base.html" %}

{% block title %}Snowfall Comparison{% endblock %}

{% block extra_head %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
<style>
  /* Layout */
  .panel { background: #f8f9fa; padding: 16px; border-radius: 8px; margin: 12px 0; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
  .controls { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
  
  /* Inputs */
  input[type="text"] { padding: 8px 12px; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px; flex: 1; min-width: 200px; }
  
  /* Buttons */
  button { padding: 8px 16px; background: #4a90d9; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; transition: background 0.2s; }
  button:hover { background: #357abd; }
  button.secondary { background: #6c757d; }
  button.secondary:hover { background: #545b62; }

  /* Autocomplete */
  .autocomplete-container { position: relative; flex: 1; max-width: 400px; }
  .autocomplete-list {
    position: absolute; top: 100%; left: 0; right: 0;
    background: white; border: 1px solid #ddd; border-radius: 6px;
    max-height: 250px; overflow-y: auto; z-index: 1000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15); margin-top: 4px;
  }
  .autocomplete-item { padding: 10px 14px; cursor: pointer; border-bottom: 1px solid #f1f1f1; }
  .autocomplete-item:last-child { border-bottom: none; }
  .autocomplete-item:hover { background: #f8f9fa; color: #4a90d9; }
  .place-name { font-weight: 600; color: #333; }
  .place-detail { font-size: 0.85em; color: #777; margin-top: 2px; }

  /* Chart Container */
  .chart-container { 
    position: relative; height: 60vh; min-height: 400px; 
    background: white; border-radius: 8px; padding: 16px;
    border: 1px solid #e9ecef;
  }

  /* Status Bar */
  .status-bar { 
    padding: 10px 16px; margin-bottom: 12px; border-radius: 6px; font-size: 14px; display: none;
    font-weight: 500;
  }
  .status-loading { background: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
  .status-error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
  .status-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }

  /* Header */
  .page-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
  .page-title { margin: 0; font-size: 1.5rem; color: #2c3e50; }
  
  /* Location Chip */
  .location-chip {
    display: inline-flex; align-items: center; gap: 8px;
    background: #e3f2fd; color: #0d47a1; padding: 6px 12px;
    border-radius: 20px; font-size: 14px; font-weight: 500;
  }
  .location-chip .coords { font-size: 0.85em; opacity: 0.8; }
</style>
{% endblock %}

{% block content %}
<div class="panel">
  <div class="page-header">
    <h2 class="page-title">Snowfall Accumulation Analysis</h2>
    <div id="locationChip" class="location-chip" style="display: none;">
      <span id="locName"></span>
      <span id="locCoords" class="coords"></span>
    </div>
  </div>

  <div class="controls">
    <div class="autocomplete-container">
      <input type="text" id="locationInput" placeholder="Search city, zip, or place..." autocomplete="off">
      <div id="autocompleteList" class="autocomplete-list" style="display: none;"></div>
    </div>
    <button id="geolocateBtn" class="secondary" title="Use My Location">üìç Me</button>
    
    <div style="flex-grow: 1;"></div>
    
    <button id="refreshBtn">Refresh</button>
  </div>
  
  <div id="statusBar" class="status-bar"></div>
</div>

<div class="chart-container">
  <canvas id="snowChart"></canvas>
</div>

<script>
// --- Configuration ---
const STORAGE_KEY_LAST_LOC = 'radarcheck_last_location';
let chartInstance = null;
let currentLat = null;
let currentLon = null;
let currentName = null;

const MODEL_COLORS = {
  'hrrr': '#2980b9',     // Blue
  'nam_nest': '#c0392b', // Red
  'gfs': '#27ae60',      // Green
  'rap': '#8e44ad',      // Purple
  'other': '#7f8c8d'     // Gray
};

// --- API Helpers ---
async function fetchJSON(url) {
  const res = await fetch(url, { headers: { 'Accept': 'application/json' }});
  if (!res.ok) throw new Error((await res.json()).error || res.statusText);
  return res.json();
}

// --- Chart Logic ---
function initChart() {
  const ctx = document.getElementById('snowChart').getContext('2d');
  chartInstance = new Chart(ctx, {
    type: 'line',
    data: { datasets: [] },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'nearest',
        axis: 'x',
        intersect: false,
      },
      plugins: {
        title: { display: true, text: 'Accumulated Snowfall - Multi-Model Comparison' },
        tooltip: {
          position: 'nearest',
          callbacks: {
            title: (items) => {
              if (!items.length) return '';
              const date = new Date(items[0].parsed.x);
              return date.toLocaleString('en-US', { 
                weekday: 'short', month: 'short', day: 'numeric', 
                hour: 'numeric', minute: '2-digit' 
              });
            },
            label: (ctx) => {
              return `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)}"`;
            }
          },
          itemSort: (a, b) => b.parsed.y - a.parsed.y // Sort tooltip by snowfall amount
        },
        zoom: {
          zoom: {
            wheel: { enabled: true },
            pinch: { enabled: true },
            mode: 'x',
          },
          pan: {
            enabled: true,
            mode: 'x',
          }
        },
        legend: {
          position: 'bottom',
          labels: { usePointStyle: true, boxWidth: 8 }
        }
      },
      scales: {
        x: {
          type: 'time',
          time: {
            unit: 'hour',
            displayFormats: { hour: 'h a' },
            tooltipFormat: 'PPpp'
          },
          title: { display: true, text: 'Local Time' },
          grid: { color: 'rgba(0,0,0,0.05)' }
        },
        y: {
          title: { display: true, text: 'Accumulated Snow (in)' },
          beginAtZero: true,
          grid: { color: 'rgba(0,0,0,0.05)' }
        }
      }
    }
  });
}

function updateChart(data) {
  if (!chartInstance) initChart();
  
  // Flatten runs to array
  const runs = Object.values(data.runs);
  
  // Sort runs by init time descending
  runs.sort((a, b) => new Date(b.init_time) - new Date(a.init_time));

  // Identify the latest run for each model to highlight it
  const latestRunByModel = {};
  runs.forEach(run => {
    if (!latestRunByModel[run.model_id]) {
      latestRunByModel[run.model_id] = run.run_id;
    }
  });
  
  const datasets = runs.map((run) => {
    const initDate = new Date(run.init_time);
    const modelName = run.model_id.toUpperCase().replace('_', ' ');
    const shortTime = initDate.toLocaleString('en-US', { hour: 'numeric', hour12: false }) + 'Z';
    const label = `${modelName} ${shortTime}`;
    
    const isLatest = latestRunByModel[run.model_id] === run.run_id;
    const baseColor = MODEL_COLORS[run.model_id] || MODEL_COLORS['other'];
    
    let color, width, dash;
    if (isLatest) {
      color = baseColor;
      width = 2.5;
      dash = [];
    } else {
      // Fade older runs
      // Use hex to rgba conversion or simple opacity hack if valid hex
      // Assuming hex inputs in MODEL_COLORS
      const r = parseInt(baseColor.slice(1, 3), 16);
      const g = parseInt(baseColor.slice(3, 5), 16);
      const b = parseInt(baseColor.slice(5, 7), 16);
      color = `rgba(${r}, ${g}, ${b}, 0.3)`;
      width = 1.5;
      dash = [4, 4];
    }

    return {
      label: label,
      data: run.series.map(pt => ({
        x: pt.valid_time,
        y: pt.value
      })),
      borderColor: color,
      backgroundColor: color,
      borderWidth: width,
      borderDash: dash,
      pointRadius: 0,
      pointHoverRadius: 4,
      fill: false,
      tension: 0.2 // Slight curve
    };
  });

  chartInstance.data.datasets = datasets;
  chartInstance.update();
  chartInstance.resetZoom();
}

// --- App Logic ---
function showStatus(msg, type) {
  const el = document.getElementById('statusBar');
  el.textContent = msg;
  el.className = `status-bar status-${type}`;
  el.style.display = 'block';
}

function updateLocationDisplay() {
  const el = document.getElementById('locationChip');
  if (currentName) {
    el.style.display = 'inline-flex';
    document.getElementById('locName').textContent = currentName;
    document.getElementById('locCoords').textContent = `(${currentLat}, ${currentLon})`;
  } else {
    el.style.display = 'none';
  }
}

async function loadData() {
  if (!currentLat || !currentLon) return;
  
  showStatus('Loading multi-model data...', 'loading');
  
  try {
    // Fetch ALL models
    const data = await fetchJSON(`/api/timeseries/multirun?lat=${currentLat}&lon=${currentLon}&model=all&variable=asnow&days=1`);
    
    if (Object.keys(data.runs).length === 0) {
      showStatus('No snowfall data available from any model.', 'error');
      if (chartInstance) {
        chartInstance.data.datasets = [];
        chartInstance.update();
      }
      return;
    }
    
    updateChart(data);
    const modelCount = new Set(Object.values(data.runs).map(r => r.model_id)).size;
    showStatus(`Loaded ${Object.keys(data.runs).length} runs from ${modelCount} models.`, 'success');
    
    setTimeout(() => { document.getElementById('statusBar').style.display = 'none'; }, 3000);
    
  } catch (e) {
    showStatus(`Error: ${e.message}`, 'error');
    console.error(e);
  }
}

function setLocation(lat, lon, name) {
  currentLat = parseFloat(lat).toFixed(4);
  currentLon = parseFloat(lon).toFixed(4);
  currentName = name;
  
  localStorage.setItem(STORAGE_KEY_LAST_LOC, JSON.stringify({ lat, lon, name }));
  updateLocationDisplay();
  loadData();
}

// --- Search / Autocomplete (Nominatim) ---
let searchTimeout;
const cache = {};

async function searchPlace(query) {
  if (cache[query]) return cache[query];
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=us&limit=5`;
  const res = await fetch(url);
  const data = await res.json();
  cache[query] = data;
  return data;
}

document.getElementById('locationInput').addEventListener('input', (e) => {
  clearTimeout(searchTimeout);
  const val = e.target.value.trim();
  const list = document.getElementById('autocompleteList');
  
  if (val.length < 3) {
    list.style.display = 'none';
    return;
  }
  
  searchTimeout = setTimeout(async () => {
    try {
      const results = await searchPlace(val);
      list.innerHTML = results.map(r => `
        <div class="autocomplete-item" data-lat="${r.lat}" data-lon="${r.lon}" data-name="${r.display_name.split(',')[0]}">
          <div class="place-name">${r.display_name.split(',')[0]}</div>
          <div class="place-detail">${r.display_name}</div>
        </div>
      `).join('');
      list.style.display = 'block';
    } catch (e) {}
  }, 300);
});

document.getElementById('autocompleteList').addEventListener('click', (e) => {
  const item = e.target.closest('.autocomplete-item');
  if (item) {
    document.getElementById('locationInput').value = item.dataset.name;
    document.getElementById('autocompleteList').style.display = 'none';
    setLocation(item.dataset.lat, item.dataset.lon, item.dataset.name);
  }
});

document.addEventListener('click', (e) => {
  if (!e.target.closest('.autocomplete-container')) {
    document.getElementById('autocompleteList').style.display = 'none';
  }
});

document.getElementById('geolocateBtn').addEventListener('click', () => {
  if (!navigator.geolocation) return showStatus('Geolocation not supported', 'error');
  showStatus('Locating...', 'loading');
  navigator.geolocation.getCurrentPosition(
    (pos) => setLocation(pos.coords.latitude, pos.coords.longitude, "My Location"),
    (err) => showStatus(`Location error: ${err.message}`, 'error')
  );
});

document.getElementById('refreshBtn').addEventListener('click', loadData);

// Init
function init() {
  const last = JSON.parse(localStorage.getItem(STORAGE_KEY_LAST_LOC));
  if (last) {
    setLocation(last.lat, last.lon, last.name);
  } else {
    setLocation(40.0, -75.0, "Philadelphia");
  }
}

initChart();
init();
</script>
{% endblock %}