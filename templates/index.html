<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>Forecast Analysis | RadarCheck</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdn.plot.ly" crossorigin>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
    <script id="plotlyScript" src="https://cdn.plot.ly/plotly-basic-2.27.0.min.js" defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet"/>
    <script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        primary: "#0ea5e9", // Sky 500
                        "background-light": "#f8fafc", // Slate 50
                        "background-dark": "#0B1120", // Custom deep dark
                        "card-dark": "#1e293b",
                        "card-light": "#ffffff",
                        "hrrr": "#3b82f6", // Blue
                        "nam_nest": "#ef4444", // Red
                        "gfs": "#22d3ee", // Cyan
                        "nbm": "#a855f7", // Purple
                        "ecmwf": "#10b981", // Emerald
                    },
                    fontFamily: {
                        display: ["Inter", "sans-serif"],
                    },
                },
            },
        };
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Fallback sizing so chart space renders instantly even before Tailwind loads */
        #chartCard { position: relative; height: 60vh; min-height: 400px; }
        #snowChart { width: 100%; height: 100%; }
        /* Lightweight skeleton shimmer while data/Plotly load */
        .chart-skeleton { position: absolute; inset: 0; z-index: 10; overflow: hidden; background: linear-gradient(180deg, rgba(148,163,184,0.10), rgba(148,163,184,0.08)); }
        html.dark .chart-skeleton { background: linear-gradient(180deg, rgba(30,41,59,0.45), rgba(30,41,59,0.4)); }
        .chart-skeleton::before { content: ""; position: absolute; inset: 0; transform: translateX(-100%); background-image: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,0.45), rgba(255,255,255,0)); animation: chart-shimmer 1.1s infinite; }
        @keyframes chart-shimmer { from { transform: translateX(-100%);} to { transform: translateX(100%);} }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-slate-800 dark:text-slate-200 min-h-screen flex flex-col font-display antialiased selection:bg-primary selection:text-white">

<!-- Minimal Header -->
<nav class="border-b border-slate-200 dark:border-slate-800 bg-white/80 dark:bg-slate-900/80 backdrop-blur-md sticky top-0 z-50">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex items-center justify-between h-16">
            <div class="flex items-center gap-2">
                <span class="material-icons-outlined text-primary text-2xl">ssid_chart</span>
                <span class="font-bold text-lg tracking-tight">Forecast Analysis</span>
            </div>
            
            <div class="flex items-center gap-2">
                <!-- System Status -->
                <a href="/status" class="p-2 rounded-full text-slate-500 hover:text-primary dark:text-slate-400 dark:hover:text-white transition-colors" title="System Status">
                    <span class="material-icons-outlined">dns</span>
                </a>

                <!-- Location Search -->
                <div class="relative group">
                    <button id="searchTrigger" class="p-2 rounded-full text-slate-500 hover:text-primary dark:text-slate-400 dark:hover:text-white transition-colors">
                        <span class="material-icons-outlined">search</span>
                    </button>
                    <div id="searchContainer" class="absolute right-0 top-12 w-72 bg-white dark:bg-slate-800 rounded-lg shadow-xl border border-slate-200 dark:border-slate-700 p-2 hidden">
                        <input type="text" id="locationInput" placeholder="Search city..." class="w-full bg-slate-100 dark:bg-slate-900 border-none rounded-md px-3 py-2 text-sm focus:ring-2 focus:ring-primary">
                        <div id="autocompleteList" class="mt-2 max-h-48 overflow-y-auto hidden"></div>
                        <button id="geolocateBtn" class="mt-2 w-full flex items-center justify-center gap-2 px-3 py-2 text-xs font-medium text-primary hover:bg-slate-100 dark:hover:bg-slate-700 rounded-md transition-colors">
                            <span class="material-icons-outlined text-sm">my_location</span> Use My Location
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</nav>

<main class="flex-grow p-4 sm:p-6 lg:p-8 max-w-7xl mx-auto w-full space-y-6">
    
    <!-- Location & Controls -->
    <div class="flex flex-col gap-4">
        <div class="flex flex-col md:flex-row md:items-center justify-between gap-4">
            <div>
                <h1 class="text-xl md:text-2xl font-semibold text-slate-900 dark:text-white flex items-center gap-2">
                    <span id="locName">Select Location</span>
                    <span class="text-xs font-mono text-slate-500 dark:text-slate-400 bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded" id="locCoords"></span>
                </h1>
                <p class="text-sm text-slate-500 dark:text-slate-400 mt-1" id="statusText">Loading...</p>
            </div>
            
            <div class="flex flex-col sm:flex-row gap-3">
                <!-- Variable Switcher -->
                <div class="bg-slate-200 dark:bg-slate-800 p-1 rounded-full flex text-sm font-medium overflow-x-auto max-w-full">
                    <button data-var="asnow" class="var-btn px-3 py-1.5 rounded-full bg-primary text-white shadow-lg shadow-primary/30 whitespace-nowrap transition">Snow</button>
                    <button data-var="t2m" class="var-btn px-3 py-1.5 rounded-full text-slate-600 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white transition whitespace-nowrap">Temp</button>
                    <button data-var="wind_10m" class="var-btn px-3 py-1.5 rounded-full text-slate-600 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white transition whitespace-nowrap">Wind</button>
                    <button data-var="gust" class="var-btn px-3 py-1.5 rounded-full text-slate-600 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white transition whitespace-nowrap">Gust</button>
                    <button data-var="apcp" class="var-btn px-3 py-1.5 rounded-full text-slate-600 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white transition whitespace-nowrap">Precip</button>
                </div>

                <!-- Time Period -->
                <div class="bg-slate-200 dark:bg-slate-800 p-1 rounded-full flex text-sm font-medium overflow-x-auto">
                    <button data-days="1" class="period-btn px-4 py-1.5 rounded-full text-slate-600 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white transition whitespace-nowrap">24h</button>
                    <button data-days="3" class="period-btn px-4 py-1.5 rounded-full text-slate-600 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white transition whitespace-nowrap">3 Days</button>
                    <button data-days="7" class="period-btn px-4 py-1.5 rounded-full bg-primary text-white shadow-lg shadow-primary/30 whitespace-nowrap">7 Days</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Chart Card -->
    <div id="chartCard" class="bg-white dark:bg-card-dark rounded-xl border border-slate-200 dark:border-slate-800 overflow-hidden shadow-sm relative h-[60vh] min-h-[400px]">
        <div id="snowChart" class="w-full h-full"></div>
        <div id="chartSkeleton" class="chart-skeleton" aria-hidden="true"></div>
    </div>

    <!-- Data Table Toggle -->
    <div class="flex justify-end">
        <button id="toggleTableBtn" class="text-sm text-primary hover:text-blue-400 font-medium transition-colors flex items-center gap-1">
            <span class="material-icons-outlined text-base">table_chart</span> Show Data Table
        </button>
    </div>

    <!-- Data Table (Hidden by default) -->
    <div id="dataTableContainer" class="hidden bg-white dark:bg-card-dark rounded-xl border border-slate-200 dark:border-slate-700 overflow-hidden shadow-sm">
        <div class="overflow-x-auto">
            <table class="w-full text-sm text-left text-slate-500 dark:text-slate-400">
                <thead class="text-xs text-slate-700 uppercase bg-slate-50 dark:bg-slate-700/50 dark:text-slate-400">
                    <tr>
                        <th class="px-6 py-3 whitespace-nowrap sticky left-0 bg-slate-50 dark:bg-slate-800 z-10">Time</th>
                        <!-- Headers injected via JS -->
                    </tr>
                </thead>
                <tbody id="dataTableBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Model Toggles (Sticky Bottom) -->
    <div class="sticky bottom-6 z-40 flex justify-center w-full px-4">
        <div class="bg-white/90 dark:bg-slate-800/90 backdrop-blur-md border border-slate-200 dark:border-slate-700 p-2 rounded-full shadow-2xl flex items-center gap-3 overflow-x-auto max-w-full no-scrollbar">
            
            <!-- HRRR -->
            <label class="cursor-pointer flex items-center gap-2 px-3 py-1.5 rounded-full bg-slate-100 dark:bg-slate-700/50 hover:bg-slate-200 dark:hover:bg-slate-700 transition select-none whitespace-nowrap">
                <input type="checkbox" class="hidden peer model-toggle" value="hrrr" checked>
                <div class="w-8 h-4 bg-slate-300 dark:bg-slate-600 rounded-full relative peer-checked:bg-hrrr/20 transition-colors">
                    <div class="w-4 h-4 bg-white dark:bg-slate-400 rounded-full absolute left-0 top-0 shadow-sm transition-all peer-checked:left-4 peer-checked:bg-hrrr"></div>
                </div>
                <span class="text-xs font-bold text-slate-700 dark:text-slate-200">HRRR</span>
            </label>

            <!-- NAM -->
            <label class="cursor-pointer flex items-center gap-2 px-3 py-1.5 rounded-full bg-slate-100 dark:bg-slate-700/50 hover:bg-slate-200 dark:hover:bg-slate-700 transition select-none whitespace-nowrap">
                <input type="checkbox" class="hidden peer model-toggle" value="nam_nest" checked>
                <div class="w-8 h-4 bg-slate-300 dark:bg-slate-600 rounded-full relative peer-checked:bg-nam_nest/20 transition-colors">
                    <div class="w-4 h-4 bg-white dark:bg-slate-400 rounded-full absolute left-0 top-0 shadow-sm transition-all peer-checked:left-4 peer-checked:bg-nam_nest"></div>
                </div>
                <span class="text-xs font-bold text-slate-700 dark:text-slate-200">NAM</span>
            </label>

            <!-- GFS -->
            <label class="cursor-pointer flex items-center gap-2 px-3 py-1.5 rounded-full bg-slate-100 dark:bg-slate-700/50 hover:bg-slate-200 dark:hover:bg-slate-700 transition select-none whitespace-nowrap">
                <input type="checkbox" class="hidden peer model-toggle" value="gfs" checked>
                <div class="w-8 h-4 bg-slate-300 dark:bg-slate-600 rounded-full relative peer-checked:bg-gfs/20 transition-colors">
                    <div class="w-4 h-4 bg-white dark:bg-slate-400 rounded-full absolute left-0 top-0 shadow-sm transition-all peer-checked:left-4 peer-checked:bg-gfs"></div>
                </div>
                <span class="text-xs font-bold text-slate-700 dark:text-slate-200">GFS</span>
            </label>

            <!-- NBM -->
            <label class="cursor-pointer flex items-center gap-2 px-3 py-1.5 rounded-full bg-slate-100 dark:bg-slate-700/50 hover:bg-slate-200 dark:hover:bg-slate-700 transition select-none whitespace-nowrap">
                <input type="checkbox" class="hidden peer model-toggle" value="nbm" checked>
                <div class="w-8 h-4 bg-slate-300 dark:bg-slate-600 rounded-full relative peer-checked:bg-nbm/20 transition-colors">
                    <div class="w-4 h-4 bg-white dark:bg-slate-400 rounded-full absolute left-0 top-0 shadow-sm transition-all peer-checked:left-4 peer-checked:bg-nbm"></div>
                </div>
                <span class="text-xs font-bold text-slate-700 dark:text-slate-200">NBM</span>
            </label>

            <!-- ECMWF -->
            <label class="cursor-pointer flex items-center gap-2 px-3 py-1.5 rounded-full bg-slate-100 dark:bg-slate-700/50 hover:bg-slate-200 dark:hover:bg-slate-700 transition select-none whitespace-nowrap">
                <input type="checkbox" class="hidden peer model-toggle" value="ecmwf_hres" checked>
                <div class="w-8 h-4 bg-slate-300 dark:bg-slate-600 rounded-full relative peer-checked:bg-ecmwf/20 transition-colors">
                    <div class="w-4 h-4 bg-white dark:bg-slate-400 rounded-full absolute left-0 top-0 shadow-sm transition-all peer-checked:left-4 peer-checked:bg-ecmwf"></div>
                </div>
                <span class="text-xs font-bold text-slate-700 dark:text-slate-200">ECMWF</span>
            </label>

        </div>
    </div>

</main>

<script>
window.onerror = function(msg, url, line, col, error) {
    const status = document.getElementById('statusText');
    if (status) {
        status.innerHTML = `<span style="color:red">Global Error: ${msg} <br> Line: ${line}</span>`;
    }
    console.error("Global Error:", msg, error);
    return false;
};

// --- Configuration ---
const STORAGE_KEY_LAST_LOC = 'radarcheck_last_location';
const STORAGE_KEY_LAST_VAR = 'radarcheck_last_variable';
const STORAGE_KEY_CACHE_PREFIX = 'radarcheck_cache_v1:';
const LOCAL_CACHE_TTL_MS = 30 * 60 * 1000; // 30 minutes
// Read API key from URL so authenticated fetches work in production
const API_KEY = new URLSearchParams(window.location.search).get('api_key') || '';
let chartInstance = null;
let currentLat = null;
let currentLon = null;
let currentName = null;
let currentData = null; // Store fetched data locally for toggling
let currentVariable = localStorage.getItem(STORAGE_KEY_LAST_VAR) || 'asnow';

const MODEL_CONFIG = {
    'hrrr': { color: '#3b82f6', glow: 'chart-glow-blue' },     // Blue
    'nam_nest': { color: '#ef4444', glow: 'chart-glow-red' }, // Red
    'gfs': { color: '#22d3ee', glow: 'chart-glow-cyan' },     // Cyan
    'nbm': { color: '#a855f7', glow: 'chart-glow-purple' },   // Purple
    'ecmwf_hres': { color: '#10b981', glow: 'chart-glow-emerald' }, // Green
    'other': { color: '#94a3b8', glow: '' }                   // Slate
};

const VAR_CONFIG = {
    'asnow': { label: 'Snowfall', unit: ' in' },
    'snod': { label: 'Snow Depth', unit: ' in' },
    'prate': { label: 'Precip Rate', unit: ' in/hr' },
    't2m': { label: 'Temperature', unit: ' °F' },
    'wind_10m': { label: 'Wind Speed', unit: ' mph' },
    'gust': { label: 'Wind Gust', unit: ' mph' },
    'apcp': { label: 'Precipitation', unit: ' in' },
    'rh': { label: 'Humidity', unit: '%' },
    'cape': { label: 'CAPE', unit: ' J/kg' },
    'msl': { label: 'Pressure', unit: ' mb' }
};

// Validate currentVariable
if (!currentVariable || !VAR_CONFIG[currentVariable]) {
    currentVariable = 'asnow';
}

// --- UI Interaction ---
document.getElementById('searchTrigger').addEventListener('click', (e) => {
    e.stopPropagation();
    const container = document.getElementById('searchContainer');
    container.classList.toggle('hidden');
    if (!container.classList.contains('hidden')) {
        document.getElementById('locationInput').focus();
    }
});

document.addEventListener('click', (e) => {
    if (!e.target.closest('#searchContainer') && !e.target.closest('#searchTrigger')) {
        document.getElementById('searchContainer').classList.add('hidden');
    }
});

document.querySelectorAll('.period-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
        // Update active state
        document.querySelectorAll('.period-btn').forEach(b => {
            b.classList.remove('bg-primary', 'text-white', 'shadow-lg', 'shadow-primary/30');
            b.classList.add('text-slate-600', 'dark:text-slate-400', 'hover:text-slate-900', 'dark:hover:text-white');
        });
        e.target.classList.remove('text-slate-600', 'dark:text-slate-400', 'hover:text-slate-900', 'dark:hover:text-white');
        e.target.classList.add('bg-primary', 'text-white', 'shadow-lg', 'shadow-primary/30');
        
        loadData(e.target.dataset.days);
    });
});

document.querySelectorAll('.var-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
        const newVar = e.target.dataset.var;
        if (newVar === currentVariable) return;

        currentVariable = newVar;
        localStorage.setItem(STORAGE_KEY_LAST_VAR, currentVariable);

        updateVarButtons();
        loadData();
    });
});

function updateVarButtons() {
    document.querySelectorAll('.var-btn').forEach(b => {
        if (b.dataset.var === currentVariable) {
            b.classList.remove('text-slate-600', 'dark:text-slate-400', 'hover:text-slate-900', 'dark:hover:text-white');
            b.classList.add('bg-primary', 'text-white', 'shadow-lg', 'shadow-primary/30');
        } else {
            b.classList.add('text-slate-600', 'dark:text-slate-400', 'hover:text-slate-900', 'dark:hover:text-white');
            b.classList.remove('bg-primary', 'text-white', 'shadow-lg', 'shadow-primary/30');
        }
    });
}

document.querySelectorAll('.model-toggle').forEach(toggle => {
    toggle.addEventListener('change', () => {
        if (currentData) updateChartSafe(currentData);
    });
});

// ... API Helpers ...
const requestCache = new Map();
const CACHE_DURATION = 300 * 1000; // 5 minutes

async function fetchJSON(url) {
    const now = Date.now();
    if (requestCache.has(url)) {
        const { timestamp, data } = requestCache.get(url);
        if (now - timestamp < CACHE_DURATION) {
            console.log('Cache hit:', url);
            return data;
        }
    }

    const headers = { 'Accept': 'application/json' };
    if (API_KEY) headers['X-API-Key'] = API_KEY;
    const res = await fetch(url, { headers });
    if (!res.ok) throw new Error((await res.json()).error || res.statusText);
    const data = await res.json();
    
    requestCache.set(url, { timestamp: now, data });
    return data;
}

// --- Render readiness + skeleton helpers ---
function whenPlotlyReady() {
    return new Promise((resolve) => {
        if (window.Plotly) return resolve();
        const s = document.getElementById('plotlyScript');
        if (s) {
            s.addEventListener('load', () => resolve(), { once: true });
        } else {
            const iv = setInterval(() => {
                if (window.Plotly) { clearInterval(iv); resolve(); }
            }, 50);
        }
    });
}

function hideChartSkeleton() {
    const el = document.getElementById('chartSkeleton');
    if (el) el.style.display = 'none';
}

function showChartSkeleton() {
    const el = document.getElementById('chartSkeleton');
    if (el) el.style.display = '';
}

async function ensureEmptyChart() {
    await whenPlotlyReady();
    if (!chartInstance) {
        const isDark = document.documentElement.classList.contains('dark');
        const layout = {
            font: { family: 'Inter, sans-serif', color: isDark ? '#94a3b8' : '#64748b' },
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)',
            margin: { l: 40, r: 20, t: 20, b: 40 },
            xaxis: { type: 'date', gridcolor: isDark ? '#334155' : '#e2e8f0', zeroline: false, fixedrange: true },
            yaxis: { gridcolor: isDark ? '#334155' : '#e2e8f0', zeroline: false, fixedrange: true },
            hovermode: false
        };
        Plotly.newPlot('snowChart', [], layout, { responsive: true, displayModeBar: false });
        chartInstance = true;
    }
}

async function updateChartSafe(data) {
    await whenPlotlyReady();
    updateChart(data);
    hideChartSkeleton();
}

function cacheKeyFor(lat, lon, variable, days) {
    return `${STORAGE_KEY_CACHE_PREFIX}${lat},${lon}|${variable}|${days}`;
}

// --- Plotly Chart Logic ---
function updateChart(data) {
    try {
        if (!chartInstance) {
            // No initChart needed for Plotly, we just newPlot
        }
        
        // Get active models from toggles
        const activeModels = Array.from(document.querySelectorAll('.model-toggle:checked')).map(cb => cb.value);
        
        // Flatten runs
        const runs = Object.values(data.runs).filter(r => activeModels.includes(r.model_id));
        
        // Sort runs by init time descending
        runs.sort((a, b) => new Date(b.init_time) - new Date(a.init_time));

        // Guard against empty runs
        if (runs.length === 0) {
            Plotly.newPlot('snowChart', [], {}, { responsive: true, displayModeBar: false });
            renderTable(data, []);
            return;
        }

        const latestRunByModel = {};
        runs.forEach(run => {
            if (!latestRunByModel[run.model_id]) {
                latestRunByModel[run.model_id] = run.run_id;
            }
        });

        const latestInit = Math.max(...runs.map(r => new Date(r.init_time).getTime()));
        
        // De-dupe runs
        const uniqueRuns = [];
        const seenRuns = new Set();
        runs.forEach(r => {
            const key = `${r.model_id}|${r.run_id}`;
            if (!seenRuns.has(key)) {
                seenRuns.add(key);
                uniqueRuns.push(r);
            }
        });

        // --- Build Traces for Plotly ---
        const traces = uniqueRuns.map(run => {
            const isLatest = latestRunByModel[run.model_id] === run.run_id;
            const modelConf = MODEL_CONFIG[run.model_id] || MODEL_CONFIG['other'];
            const modelName = run.model_id.toUpperCase().replace('_', ' ');
            
            // Ghosting logic
            const runDate = new Date(run.init_time);
            const ageHours = (latestInit - runDate.getTime()) / 3600000;
            
            let opacity = 1.0;
            let width = 3;
            let name = modelName;

            if (!isLatest) {
                if (ageHours < 12) {
                    opacity = 0.7;
                    width = 2.5;
                } else {
                    opacity = 0.4;
                    width = 2;
                }
                // Less aggressive fade rate, higher floor
                opacity = Math.max(0.3, opacity - (ageHours / 200));
                name += ` (${Math.round(ageHours)}h ago)`;
            } else {
                name += " (Latest)";
            }
            
            // Extract X and Y - convert to Date objects for local timezone display
            const x = run.series.map(p => new Date(p.valid_time));
            const y = run.series.map(p => p.value);

            return {
                x: x,
                y: y,
                type: 'scatter',
                mode: 'lines',
                name: name,
                line: {
                    color: modelConf.color,
                    width: width
                },
                opacity: opacity,
                hoverinfo: 'y+name',
                hovertemplate: `<b>${name}</b>: %{y:.1f}${(VAR_CONFIG[currentVariable] || {unit:''}).unit}<extra></extra>`
            };
        });

        // --- Layout Config ---
        const isDark = document.documentElement.classList.contains('dark');
        const periodBtn = document.querySelector('.period-btn.bg-primary');
        const selectedDays = periodBtn ? parseInt(periodBtn.dataset.days) : 3;
        
        // Determine Time Range
        const now = new Date();
        const startHour = Math.floor(now.getHours() / 6) * 6;
        const startTime = new Date(now);
        startTime.setHours(startHour, 0, 0, 0);
        const endTime = new Date(startTime.getTime() + selectedDays * 24 * 60 * 60 * 1000);
        
        // Determine Tick Interval (dtick) based on selected days
        let dtick = 21600000; // 1 Day: 6 hours
        if (selectedDays > 1) dtick = 43200000; // 3 Days: 12 hours
        if (selectedDays > 3) dtick = 86400000; // 7 Days: 24 hours

        const layout = {
            font: {
                family: 'Inter, sans-serif',
                color: isDark ? '#94a3b8' : '#64748b'
            },
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)',
            margin: { l: 40, r: 20, t: 20, b: 40 },
            showlegend: false, // We use custom toggles
            xaxis: {
                type: 'date',
                range: [startTime, endTime],
                tickformat: '%-I %p\n%a %b %d', // "6 AM \n Sat Jan 24"
                tick0: startTime,
                dtick: dtick,
                gridcolor: isDark ? '#334155' : '#e2e8f0',
                zeroline: false,
                fixedrange: true // Disable zoom on x-axis to keep strict range
            },
            yaxis: {
                gridcolor: isDark ? '#334155' : '#e2e8f0',
                zeroline: false,
                fixedrange: true // Disable zoom on y-axis
            },
            hovermode: false, // Tooltip disabled per user request
            hoverlabel: {
                bgcolor: isDark ? '#1e293b' : '#ffffff',
                bordercolor: isDark ? '#475569' : '#cbd5e1',
                font: { color: isDark ? '#f8fafc' : '#0f1742' }
            }
        };

        const config = {
            responsive: true,
            displayModeBar: false
        };

        // Use Plotly.react for efficient updates (diffing)
        Plotly.react('snowChart', traces, layout, config);
        chartInstance = true; // Mark as initialized
        
        // Also build the table using a timeline for interpolation
        // Create master timeline
        const masterTimeline = [];
        let t = startTime.getTime();
        const endT = endTime.getTime();
        while (t <= endT) {
            masterTimeline.push(t);
            t += 3600000;
        }
        renderTable(data, masterTimeline);
    } catch (e) {
        console.error("Chart Error:", e);
        const statusEl = document.getElementById('statusText');
        if (statusEl) statusEl.innerHTML = `<span style="color:red">Chart Error: ${e.message}</span>`;
    }
}

function interpolateValue(series, targetTime) {
    if (!series || !series.length) return null;
    const times = series.map(p => new Date(p.valid_time).getTime());
    const idx = times.indexOf(targetTime);
    if (idx !== -1) return series[idx].value;

    let leftIdx = -1, rightIdx = -1;
    for (let i = 0; i < times.length; i++) {
        if (times[i] < targetTime) leftIdx = i;
        if (times[i] > targetTime) {
            rightIdx = i;
            break;
        }
    }
    if (leftIdx === -1 || rightIdx === -1) return null;

    const t1 = times[leftIdx], v1 = series[leftIdx].value;
    const t2 = times[rightIdx], v2 = series[rightIdx].value;
    return v1 + (v2 - v1) * ((targetTime - t1) / (t2 - t1));
}

function renderTable(data, timeline) {
    try {
        const tableBody = document.getElementById('dataTableBody');
        const tableHeadRow = document.querySelector('#dataTableContainer thead tr');

        if (!tableBody || !tableHeadRow) return;

        // Clear existing
        tableBody.innerHTML = '';
        tableHeadRow.innerHTML = '<th class="px-4 py-3 whitespace-nowrap sticky left-0 bg-slate-50 dark:bg-slate-800 z-10">Time</th>';

        // Get active models from toggles
        const activeModels = Array.from(document.querySelectorAll('.model-toggle:checked')).map(cb => cb.value);

        // Group runs by model
        const runsByModel = {};
        Object.values(data.runs).forEach(run => {
            if (!activeModels.includes(run.model_id)) return;
            if (!runsByModel[run.model_id]) runsByModel[run.model_id] = [];
            runsByModel[run.model_id].push(run);
        });

        const SYNOPTIC_HOURS = ['00', '12'];
        const selectedRuns = [];

        Object.entries(runsByModel).forEach(([modelId, runs]) => {
            runs.sort((a, b) => new Date(b.init_time) - new Date(a.init_time));
            const getRunHour = (run) => run.run_id.slice(-2);
            const synopticRuns = runs.filter(r => SYNOPTIC_HOURS.includes(getRunHour(r)));
            const nonSynopticRuns = runs.filter(r => !SYNOPTIC_HOURS.includes(getRunHour(r)));
            let selected = [];
            if (synopticRuns.length > 0) {
                selected = nonSynopticRuns.slice(0, 2);
                selected.push(synopticRuns[0]);
            } else {
                selected = runs.slice(0, 3);
            }
            selected.sort((a, b) => new Date(b.init_time) - new Date(a.init_time));
            selected.forEach(run => selectedRuns.push({ ...run, modelId }));
        });

        const modelOrder = ['hrrr', 'nam_nest', 'gfs', 'ecmwf_hres', 'nbm'];
        selectedRuns.sort((a, b) => {
            const orderA = modelOrder.indexOf(a.modelId);
            const orderB = modelOrder.indexOf(b.modelId);
            if (orderA !== orderB) return orderA - orderB;
            return new Date(b.init_time) - new Date(a.init_time);
        });

        const modelColors = {
            'hrrr': '#3b82f6',
            'nam_nest': '#ef4444',
            'gfs': '#22d3ee',
            'nbm': '#a855f7',
            'ecmwf_hres': '#10b981'
        };

        selectedRuns.forEach(run => {
            const th = document.createElement('th');
            th.className = "px-3 py-2 text-xs whitespace-nowrap";
            const runHour = run.run_id.slice(-2) + 'Z';
            const isSynoptic = SYNOPTIC_HOURS.includes(run.run_id.slice(-2));
            const color = modelColors[run.modelId] || '#94a3b8';
            const initDate = new Date(run.init_time);
            const dateStr = initDate.toLocaleString('en-US', { month: 'short', day: 'numeric' });
            th.innerHTML = `<span style="color: ${color}">${run.model_id.toUpperCase().replace('_', ' ')}</span><br><span class="text-slate-500 font-normal">${dateStr} ${runHour}${isSynoptic ? '*' : ''}</span>`;
            tableHeadRow.appendChild(th);
        });

        const runData = selectedRuns.map(run => {
            return timeline.map(t => interpolateValue(run.series, t));
        });

        const HOUR_STEP = 3;
        timeline.forEach((time, idx) => {
            if (idx % HOUR_STEP !== 0) return;

            const date = new Date(time);
            const tr = document.createElement('tr');
            tr.className = "bg-white border-b dark:bg-card-dark dark:border-slate-700 hover:bg-slate-50 dark:hover:bg-slate-800";

            const timeCell = document.createElement('td');
            timeCell.className = "px-4 py-2 text-xs font-medium text-slate-900 dark:text-white whitespace-nowrap sticky left-0 bg-white dark:bg-card-dark";
            const h = date.getHours();
            if (h === 0) {
                timeCell.innerHTML = `<span class="font-bold">${date.toLocaleString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })}</span><br>12 AM`;
            } else {
                timeCell.textContent = date.toLocaleString('en-US', { hour: 'numeric' });
            }
            tr.appendChild(timeCell);

            runData.forEach((data, runIdx) => {
                const td = document.createElement('td');
                td.className = "px-3 py-2 text-xs text-center";
                const val = data[idx];
                if (val !== null) {
                    td.textContent = val.toFixed(1) + VAR_CONFIG[currentVariable].unit;
                } else {
                    td.textContent = '-';
                    td.classList.add('text-slate-400');
                }
                tr.appendChild(td);
            });

            tableBody.appendChild(tr);
        });
    } catch (e) {
        console.error("Table Error:", e);
    }
}

document.getElementById('toggleTableBtn').addEventListener('click', () => {
    const container = document.getElementById('dataTableContainer');
    container.classList.toggle('hidden');
    const btn = document.getElementById('toggleTableBtn');
    btn.innerHTML = container.classList.contains('hidden') 
        ? '<span class="material-icons-outlined text-base">table_chart</span> Show Data Table'
        : '<span class="material-icons-outlined text-base">expand_less</span> Hide Data Table';
});

async function loadData(daysOverride = null) {
    if (!currentLat || !currentLon) return;
    
    updateVarButtons();

    let days = daysOverride;
    if (!days) {
        const periodBtn = document.querySelector('.period-btn.bg-primary');
        days = periodBtn ? periodBtn.dataset.days : '3';
    }
    // Show skeleton and render an empty chart immediately
    showChartSkeleton();
    ensureEmptyChart().catch(() => {});

    const statusEl = document.getElementById('statusText');
    statusEl.textContent = 'Updating forecast...';

    // Try localStorage cache for instant render
    const key = cacheKeyFor(currentLat, currentLon, currentVariable, String(days));
    try {
        const cached = localStorage.getItem(key);
        if (cached) {
            const parsed = JSON.parse(cached);
            const freshEnough = parsed && parsed.ts && (Date.now() - parsed.ts) < LOCAL_CACHE_TTL_MS;
            if (parsed && parsed.data && freshEnough) {
                currentData = parsed.data;
                updateChartSafe(currentData);
                statusEl.textContent = 'Showing cached forecast… updating…';
            }
        }
    } catch (e) {
        console.debug('Cache read failed', e);
    }
    
    try {
        const url = `/api/timeseries/multirun?lat=${currentLat}&lon=${currentLon}&model=all&variable=${currentVariable}&days=${days}`;
        console.log('Fetching:', url);
        const data = await fetchJSON(url);
        console.log('Got data, runs:', Object.keys(data.runs).length);
        currentData = data; // Store for toggling
        await updateChartSafe(data);
        // persist to localStorage for instant render on reload
        try { localStorage.setItem(key, JSON.stringify({ ts: Date.now(), data })); } catch {}
        const modelCount = new Set(Object.values(data.runs).map(r => r.model_id)).size;
        statusEl.textContent = `Forecast from ${modelCount} models`;
        
        // Trigger background preload for other variables
        preloadData(days);

    } catch (e) {
        statusEl.textContent = `Error: ${e.message}`;
        console.error('loadData error:', e);
        console.error('Stack:', e.stack);
    }
}

async function preloadData(days) {
    for (const varId of Object.keys(VAR_CONFIG)) {
        if (varId === currentVariable) continue;
        
        const url = `/api/timeseries/multirun?lat=${currentLat}&lon=${currentLon}&model=all&variable=${varId}&days=${days}`;
        // We just fetch to populate cache, we don't use the result here
        fetchJSON(url).catch(e => console.debug(`Preload failed for ${varId}:`, e));
    }
}

function setLocation(lat, lon, name) {
    const parsedLat = parseFloat(lat);
    const parsedLon = parseFloat(lon);
    if (isNaN(parsedLat) || isNaN(parsedLon)) {
        console.warn('Invalid coordinates:', lat, lon);
        return;
    }
    currentLat = parsedLat.toFixed(4);
    currentLon = parsedLon.toFixed(4);
    currentName = name;
    
    document.getElementById('locName').textContent = name;
    document.getElementById('locCoords').textContent = `${currentLat}, ${currentLon}`;
    
    localStorage.setItem(STORAGE_KEY_LAST_LOC, JSON.stringify({ lat, lon, name }));
    loadData();
}

// --- Search Logic (Nominatim) ---
let searchTimeout;
document.getElementById('locationInput').addEventListener('input', (e) => {
    clearTimeout(searchTimeout);
    const val = e.target.value.trim();
    const list = document.getElementById('autocompleteList');
    
    if (val.length < 3) { list.classList.add('hidden'); return; }
    
    searchTimeout = setTimeout(async () => {
        try {
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(val)}&countrycodes=us&limit=5`;
            const res = await fetch(url);
            const results = await res.json();
            
            list.innerHTML = results.map(r => `
                <div class="autocomplete-item p-2 hover:bg-slate-100 dark:hover:bg-slate-700 cursor-pointer rounded" 
                     data-lat="${r.lat}" data-lon="${r.lon}" data-name="${r.display_name.split(',')[0]}">
                    <div class="font-medium text-slate-800 dark:text-slate-200">${r.display_name.split(',')[0]}</div>
                    <div class="text-xs text-slate-500">${r.display_name}</div>
                </div>
            `).join('');
            list.classList.remove('hidden');
        } catch (e) {}
    }, 300);
});

document.getElementById('autocompleteList').addEventListener('click', (e) => {
    const item = e.target.closest('.autocomplete-item');
    if (item) {
        setLocation(item.dataset.lat, item.dataset.lon, item.dataset.name);
        document.getElementById('searchContainer').classList.add('hidden');
    }
});

document.getElementById('geolocateBtn').addEventListener('click', () => {
    if (!navigator.geolocation) return;
    navigator.geolocation.getCurrentPosition(
        (pos) => {
            setLocation(pos.coords.latitude, pos.coords.longitude, "My Location");
            document.getElementById('searchContainer').classList.add('hidden');
        }
    );
});

// Init
let last = null;
try {
    last = JSON.parse(localStorage.getItem(STORAGE_KEY_LAST_LOC));
} catch (e) {
    console.warn('Failed to parse stored location:', e);
}
if (last && last.lat && last.lon) {
    setLocation(last.lat, last.lon, last.name || 'Saved Location');
} else {
    setLocation(40.0488, -75.3890, "Philadelphia");
}

</script>
</body>
</html>
